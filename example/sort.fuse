// Bubble sort implementation for performance testing

global array = []
global idx = 1

fn initialize() once -> void {
  startTimestamp = 0
  array.clear()
  idx = 1
  while (idx <= 10000) {
    array.push(math.random(1, 10000))
    idx++
  }
  idx = 1
}

global n = 0
global i = 0
global j = 0
global temp = 0

fn sort() once -> void {
  // Sort the array using bubble sort
  n = array.length
  i = 0
  j = 0
  temp = 0
  while (i <= n) {
    j = 0
    while (j <= n - i - 1) {
      if (array[j] > array[j + 1]) {
        // Swap array[j] and array[j + 1]
        temp = array[j]
        array[j] = array[j + 1]
        array[j + 1] = temp
      }
      j++
    }
    i++
  }
}

fn current_timestamp() once -> any {
  return sensing.daysSince2000() * 86400
}

fn warmup() once -> void {
  initialize()
  sort()
}

global startTimestamp = 0

fn test() once -> void {
  initialize()
  startTimestamp = current_timestamp()
  sort()
  looks.say("Sorting took " .. (current_timestamp() - startTimestamp) .. " seconds")
}

fn main() once -> void {
  looks.say("Warmup")
  warmup()
  test()
}

event.start {
  main()
}